# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

require 'cucumber/rails'
require 'capybara/poltergeist'
require 'lingua_franca/capybara'
require 'mocha/mini_test'

# Capybara defaults to CSS3 selectors rather than XPath.
# If you'd prefer to use XPath, just uncomment this line and adjust any
# selectors in your step definitions to use the XPath syntax.
# Capybara.default_selector = :xpath

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
ActionController::Base.allow_rescue = false

# Remove/comment out the lines below if your app doesn't have a database.
# For some databases (like MongoDB and CouchDB) you may need to use :truncation instead.
begin
	DatabaseCleaner.strategy = :truncation
	#DatabaseCleaner.clean_with(:truncation)
rescue NameError
	raise "You need to add database_cleaner to your Gemfile (in the :test group) if you wish to use it."
end

Before('@javascript') do
	ActiveRecord::Base.shared_connection = nil
	ActiveRecord::Base.descendants.each do |model|
		model.shared_connection = nil
	end
end

Before do
	# user_agent = "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36"
	user_agent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A"
	#request.stub!(:user_agent).and_return()
	#controller.request.stub!(:user_agent).and_return(user_agent)
	ActionDispatch::Request.any_instance.stubs(:user_agent).returns(user_agent)
	#page.driver.browser.header('User-Agent', user_agent)
	#page.driver.headers = { "User-Agent" => "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2403.157 Safari/537.36" }
end

After do |scenario|
	#save_and_open_page if scenario.failed?
	puts " = PAGE START = \n#{page.html}\n = PAGE END = " if scenario.failed?
	#puts page.find('#main')['innerHTML'] if scenario.failed?
end

After do
	DatabaseCleaner.clean
end

#After('suite') do
#	puts " ============ #{After all} ============ "
#end

# You may also want to configure DatabaseCleaner to use different strategies for certain features and scenarios.
# See the DatabaseCleaner documentation for details. Example:
#
#   Before('@no-txn,@selenium,@culerity,@celerity,@javascript') do
#     # { :except => [:widgets] } may not do what you expect here
#     # as Cucumber::Rails::Database.javascript_strategy overrides
#     # this setting.
#     DatabaseCleaner.strategy = :truncation
#   end
#
#   Before('~@no-txn', '~@selenium', '~@culerity', '~@celerity', '~@javascript') do
#     DatabaseCleaner.strategy = :transaction
#   end
#

# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
Capybara.register_driver :bb_poltergeist do |app|
	I18n.backend.start_recording_html(Capybara::LinguaFrancaPoltergeist::Driver.new(app, :inspector => true, :timeout => 120))
end

Cucumber::Rails::Database.javascript_strategy = :transaction
Capybara.default_driver = :bb_poltergeist
Capybara.javascript_driver = :bb_poltergeist
Geocoder.configure(:timeout => 60)

def locate(id)
	id = id.gsub(/\s+/, '_')
	e = page.all("[name=\"#{id}\"], [id=\"#{id}\"]")
	if e.length
		return e.first[:id]
	end
	page.all("[name$=\"#{id}\"], [id$=\"#{id}\"]").first[:id]
end

def create_org(name = nil, location = nil)
	org = FactoryGirl.create(:org)
	found_location = nil
	if location.present?
		cache_file = File.join(File.dirname(__FILE__), 'location_cache.yml')
		cache = {}
		if File.exists?(cache_file)
			begin
				cache = YAML.load_file(cache_file)
			rescue
				# get rid of the cache if there's an error
			end
		end
		l = cache[location]
		if l.nil?
			l = Geocoder.search(location).first
			cache[location] = l
			File.open(cache_file, 'w') { |f| f.write cache.to_yaml }
		end
		begin
			found_location = Location.new(city: l.city, territory: l.province_code, country: l.country_code, latitude: l.latitude, longitude: l.longitude)
		rescue; end
		if found_location.nil?
			# let it though, we might be offline
			org.save!
			return org
		end
	end
	if name.present?
		org.name = name
		org.slug = org.generate_slug(name, found_location)
	end
	if found_location.present?
		org.locations << found_location
	end
	org.save!
	org
end

def get_language_code(language)
	languages = {
		'english' => 'en',
		'french' => 'fr',
		'spanish' => 'es',
		'german' => 'de'
	}
	languages[language.downcase]
end
